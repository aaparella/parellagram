Title: Go, Tooling, and New Languages
Date: February 14, 2016

The more I play with new technologies and tools, the more I appreciate things that I used to take for granted. I used to consider differences between languages to be litle more than semantic. Of course, in time I've come to realize that was incredibly stupid, and appreciate that there is far more that set languages apart than the syntax they use for loops. And the more I've been working with Go lately, the more I've realized that a languages tooling is by far one of its most important differentiatiors. 

Put simply, the Go tooling is great. Really great. With a single brew install we get a zero-config project build tool, race condition detector, un-configurable code formatter (Which [is](https://pypi.python.org/pypi/pyfmt/) [being](https://github.com/morishitter/cssfmt) [copied](https://twitter.com/jiaaro/status/476380810258690049) [with](https://github.com/wojtekmach/rubyfmt) [alarming](https://github.com/Hackerpilot/dfmt) [frequency](https://github.com/weavejester/cljfmt)), documentation browser, testing framework, automatic free documentation generation and hosting, and more. 

These aren't simple, half-assed tools, either. These tools, along with Go being a pretty great language, make writing safe, proper Go code a genuine pleasure. It's why I've written my last three projects (including [this website!](http://github.com/aaparella/parellagram), and numerous smaller ones) in Go. I really, really enjoy it.

As far as I'm concerned, any new language (Looking at you D, Rust, Swift) will need to have at least a comparable tooling story. After using Go extensively, going back to C++ was a cold splash of water. Hand written Makefiles / Cmake? No built in dependency management? *Far* worse editor integration? How did I ever live like this? None of this is to say that languages without such tools are bad languages, or shouldn't be used. Even a number of languages with mature and widely used tooling sometimes manage to screw it up (*cough* Ruby *cough*). I *really* like C and C++, I just wish that writing in them didn't require wading through massive amounts of documentation for platform specific tools. A cross platform, high quality set of tools goes an extremely long way.

This is also a trend I've noticed in a number of new languages. I called them out earlier, but Swift and Rust both have quite good tooling, with the swift build tool and playgrounds, and Rust's *excellent* Cargo tool. There are quite a few new languages garnering a lot of attention, and almost all of them are placing a very strong emphasis, rightfully so, on tooling. It really is enough to make a good language and great one. Or at least, make a good programming experience a great one. It highlights just how important these tools, and the overall experience of working in a language, is.

If you haven't given Go a chance, I highly recommend it. Even if not for it's simplicity, portability, concurrency primitives, adorable mascot, and performance (The garbage collector is [nuts](https://twitter.com/brianhatfield/status/692778741567721473). If you've ever thought that the tooling for your favorite language wasn't quite what it could be, try a language that proves you right.

Also, what did *you* do on your Valentine's day? Not write about your favorite programming language? Sounds lame.
